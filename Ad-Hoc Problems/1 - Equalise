time limit per test1 second
memory limit per test256 megabytes
inputstandard input
outputstandard output
You are given two binary strings ğ‘ and ğ‘ of the same length. You can perform the following two operations on the string ğ‘:

Swap any two bits at indices ğ‘– and ğ‘— respectively (1â‰¤ğ‘–,ğ‘—â‰¤ğ‘›), the cost of this operation is |ğ‘–âˆ’ğ‘—|, that is, the absolute difference between ğ‘– and ğ‘—.
Select any arbitrary index ğ‘– (1â‰¤ğ‘–â‰¤ğ‘›) and flip (change 0 to 1 or 1 to 0) the bit at this index. The cost of this operation is 1.
Find the minimum cost to make the string ğ‘ equal to ğ‘. It is not allowed to modify string ğ‘.

Input
The first line contains a single integer ğ‘› (1â‰¤ğ‘›â‰¤106) â€” the length of the strings ğ‘ and ğ‘.

The second and third lines contain strings ğ‘ and ğ‘ respectively.

Both strings ğ‘ and ğ‘ have length ğ‘› and contain only '0' and '1'.

Output
Output the minimum cost to make the string ğ‘ equal to ğ‘.

Examples
inputCopy
3
100
001
outputCopy
2
inputCopy
4
0101
0011
outputCopy
1
Note
In the first example, one of the optimal solutions is to flip index 1 and index 3, the string ğ‘ changes in the following way: "100" â†’ "000" â†’ "001". The cost is 1+1=2.

The other optimal solution is to swap bits and indices 1 and 3, the string ğ‘ changes then "100" â†’ "001", the cost is also |1âˆ’3|=2.

In the second example, the optimal solution is to swap bits at indices 2 and 3, the string ğ‘ changes as "0101" â†’ "0011". The cost is |2âˆ’3|=1.

Solution:
#include <iostream>
#include <string>
using namespace std;

int update(string a, string b)
{
    if(a.size() == 0)
        return 0;
    if(a[0] == b[0])
        return update(a.substr(1), b.substr(1));
    if((a[0] == b[1]) && (a[1] == b[0]) && (a[0] != a[1]))
        return 1 + update(a.substr(2), b.substr(2));
    return 1 + update(a.substr(1), b.substr(1));
}

int main()
{
    string a, b;
    cin >> a >> b;
    cout << update(a, b);
}

